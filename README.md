## Book
- [Effective Python 第3版](https://www.oreilly.co.jp/books/9784814401338/)
- [GitHub](https://github.com/bslatkin/effectivepython/tree/main)
- Purchase Date: 251019 (DRMfree)

<img src="https://www.oreilly.co.jp/books/images/picture_large978-4-8144-0133-8.jpeg" height=150px>

## CheckList
- [ ] **1章　Pythonicな考え方**
  - [ ] 項目1　使用するPythonのバージョンを把握する
  - [ ] 項目2　PEP 8スタイルガイドに従う
  - [ ] 項目3　Pythonがコンパイル時にエラーを検出することを期待しない
  - [ ] 項目4　複雑な式ではなくヘルパー関数を定義する
  - [ ] 項目5　インデックス参照ではなくアンパックを使う
  - [ ] 項目6　単一要素からなるタプルは常に丸括弧で囲む
  - [ ] 項目7　単純なインラインロジックには条件式を使う
  - [ ] 項目8　代入式で繰り返しを防ぐ
  - [ ] 項目9　制御構造をパターンマッチで分割する（ただし、if文で十分な場合は使わない）

- [ ] **2章　文字列とスライス**
  - [ ] 項目10　bytesとstrの違いを理解する
  - [ ] 項目11　Cスタイルフォーマット文字列やstr.formatは使わずにフォーマット済み文字列を使う
  - [ ] 項目12　オブジェクト出力におけるreprとstrの違いを理解する
  - [ ] 項目13　暗黙的な結合よりも明示的な結合を優先する
  - [ ] 項目14　スライスの仕組みを理解する
  - [ ] 項目15　同一式でスライスとストライドを一緒に使わない
  - [ ] 項目16　スライスではなくcatch-allアンパックを使う

- [ ] **3章　ループとイテレータ**
  - [ ] 項目17　rangeよりenumerateを優先する
  - [ ] 項目18　zipを使ってイテレータを並列に処理する
  - [ ] 項目19　forループとwhileループのelseブロックを避ける
  - [ ] 項目20　ループが終了した後にループ変数を使わない
  - [ ] 項目21　引数をイテレートする際は防御的に行う
  - [ ] 項目22　イテレート中にコンテナを変更せず、代わりにコピーやキャッシュを使う
  - [ ] 項目23　anyとallで効率的な短絡評価をする
  - [ ] 項目24　イテレータとジェネレータを扱う際はitertoolsを検討する

- [ ] **4章　辞書**
  - [ ] 項目25　辞書の挿入順序に依存する際は注意する
  - [ ] 項目26　辞書の欠落したキーにはget()を使う
  - [ ] 項目27　内部状態の欠落要素にはsetdefaultではなくdefaultdictで対応する
  - [ ] 項目28　_missing__()を使ってキー依存のデフォルト値を生成する
  - [ ] 項目29　辞書、リスト、タプルを深くネストする代わりにクラスを定義する

- [ ] **5章　関数**
  - [ ] 項目30　関数の引数がミュータブルであることを知っておく
  - [ ] 項目31　関数の呼び出し元で4つ以上の変数をアンパックせず、専用のオブジェクトを返す
  - [ ] 項目32　Noneを返さずに例外を送出する
  - [ ] 項目33　クロージャが変数スコープとnonlocalとどのように相互作用するかを理解する
  - [ ] 項目34　可変位置引数で可読性を向上させる
  - [ ] 項目35　キーワード引数でオプションの動作を付与する
  - [ ] 項目36　Noneとdocstringを使って動的なデフォルト引数を指定する
  - [ ] 項目37　キーワード専用と位置専用引数で明確さを強調する
  - [ ] 項目38　functools.wrapsを使って関数デコレータを定義する
  - [ ] 項目39　グルー関数にはlambda式よりfunctools.partialを優先する

- [ ] **6章　内包表記とジェネレータ**
  - [ ] 項目40　mapやfilterの代わりに内包表記を使う
  - [ ] 項目41　内包表記では式を3つ以上使わない
  - [ ] 項目42　代入式を使って内包表記の繰り返しを減らす
  - [ ] 項目43　リストではなくジェネレータを返す
  - [ ] 項目44　大きな内包表記にはジェネレータ式を使う
  - [ ] 項目45　yield fromでジェネレータを組み合わせる
  - [ ] 項目46　send()を呼び出す代わりにイテレータをジェネレータに渡す
  - [ ] 項目47　ジェネレータのthrowメソッドではなくクラスで状態遷移を管理する

- [ ] **7章　クラスとインタフェース**
  - [ ] 項目48　単純なインタフェースにはクラスではなく関数を使う
  - [ ] 項目49　isinstanceよりもポリモーフィズムを優先する
  - [ ] 項目50　オブジェクト指向ポリモーフィズムの代わりに関数型シングルディスパッチを検討する
  - [ ] 項目51　軽量クラスを定義するためにdataclassesを優先する
  - [ ] 項目52　@classmethodポリモーフィズムを使ってオブジェクトをジェネリックに構築する
  - [ ] 項目53　superで基底クラスを初期化する
  - [ ] 項目54　mix-inクラスで機能を追加する
  - [ ] 項目55　プライベート属性よりもパブリック属性を優先する
  - [ ] 項目56　イミュータブルオブジェクトを作成するためにdataclassesを優先する
  - [ ] 項目57　カスタムコンテナ型はcollections.abcクラスから継承する

- [ ] **8章　メタクラスと属性**
  - [ ] 項目58　setterおよびgetterメソッドの代わりにパブリック属性を使う
  - [ ] 項目59　属性をリファクタリングする代わりに@propertyを使う
  - [ ] 項目60　再利用可能な@propertyメソッドのためにディスクリプタを使う
  - [ ] 項目61　遅延属性のために__getattr__、__getattribute__、__setattr__を使う
  - [ ] 項目62　__init_subclass__による派生クラスの検証
  - [ ] 項目63　__init_subclass__によるクラス登録
  - [ ] 項目64　_set_name__でクラス属性にアノテーションを付与する
  - [ ] 項目65　属性間の関係を考慮したクラス本文の定義順序を考える
  - [ ] 項目66　合成可能なクラス拡張のためにメタクラスよりもクラスデコレータを優先する

- [ ] **9章　並行性と並列性**
  - [ ] 項目67　subprocessでサブプロセスを管理する
  - [ ] 項目68　スレッドはブロッキングI/Oのために使う
  - [ ] 項目69　Lockを使ってスレッド間のデータ競合を防ぐ
  - [ ] 項目70　Queueを使ってスレッド間の作業を調整する
  - [ ] 項目71　並行性が必要な状況を認識する
  - [ ] 項目72　オンデマンドファンアウト用に新しいスレッドインスタンスを生成しない
  - [ ] 項目73　Queueを使った並行性にはリファクタリングが必要であることを理解する
  - [ ] 項目74　並行処理にスレッドを使うのであればThreadPoolExecutorを検討する
  - [ ] 項目75　コルーチンで高い並行I/Oを実現する
  - [ ] 項目76　スレッド化されたI/Oをasyncioに移植する方法を把握する
  - [ ] 項目77　スレッドとコルーチンでasyncioへの移行を容易にする
  - [ ] 項目78　非同期対応のワーカースレッドでasyncioイベントループの応答性を最大化する
  - [ ] 項目79　真の並列処理にはconcurrent.futuresを検討する

- [ ] **10章　ロバストネス**
  - [ ] 項目80　try/except/else/finallyブロックを使う
  - [ ] 項目81　assertで前提条件を検証して、raiseで予想外の事象を通知する
  - [ ] 項目82　contextlibとwith文で再利用可能なtry/finallyの振る舞いを実現する
  - [ ] 項目83　tryブロックを可能な限り短く保つ
  - [ ] 項目84　例外変数が消失することに注意する
  - [ ] 項目85　注意してExceptionクラスを捕捉する
  - [ ] 項目86　ExceptionとBaseExceptionの違いを理解する
  - [ ] 項目87　tracebackによる高度な例外報告
  - [ ] 項目88　例外を明示的に連鎖させてトレースバックを明確にする
  - [ ] 項目89　ジェネレータには常にリソースを渡し、呼び出し元でクリーンアップする
  - [ ] 項目90　__debug__をFalseにしない
  - [ ] 項目91　開発者ツールを実装する場合を除いてexecとevalを使わない

- [ ] **11章　パフォーマンス**
  - [ ] 項目92　最適化前にプロファイリングを行う
  - [ ] 項目93　timeitを使ってパフォーマンスが重要なコードを最適化する
  - [ ] 項目94　Pythonを別のプログラミング言語に置き換えるタイミングと方法を知る
  - [ ] 項目95　ctypesでネイティブライブラリと迅速に統合する
  - [ ] 項目96　拡張モジュールでパフォーマンスと利便性を高める
  - [ ] 項目97　コンパイル済みバイトコードとキャッシュで起動時間を短縮する
  - [ ] 項目98　動的インポートによるモジュールの遅延読み込みで起動時間を削減する
  - [ ] 項目99　ゼロコピー処理のためにmemoryviewとbytearrayを使う

- [ ] **12章　データ構造とアルゴリズム**
  - [ ] 項目100　keyパラメータによる複雑なソート
  - [ ] 項目101　sort()とsorted()の違いを理解する
  - [ ] 項目102　ソート済みシーケンスにはbisectを使う
  - [ ] 項目103　プロデューサ・コンシューマキューにはdequeを使う
  - [ ] 項目104　優先度付きキューとしてheapqを使う
  - [ ] 項目105　datetimeを使ってローカル時刻を扱う
  - [ ] 項目106　精度が極めて重要な場合はdecimalを使う
  - [ ] 項目107　copyregでpickleを管理する

- [ ] **13章　テストとデバッグ**
  - [ ] 項目108　TestCaseでテストを実装する
  - [ ] 項目109　ユニットテストよりも統合テストを優先する
  - [ ] 項目110　setUp、tearDown、setUpModule、tearDownModuleでテストを互いに分離する
  - [ ] 項目111　複雑な依存関係はモックする
  - [ ] 項目112　依存関係をカプセル化してモックとテストを容易にする
  - [ ] 項目113　浮動小数点数のテストではassertAlmostEqualを使う
  - [ ] 項目114　pdbによるインタラクティブデバッグ
  - [ ] 項目115　tracemallocを使ってメモリ使用量とメモリリークを把握する

- [ ] **14章　コラボレーション**
  - [ ] 項目116　サードパーティライブラリの探し方
  - [ ] 項目117　仮想環境を使う
  - [ ] 項目118　必ずdocstringを書く
  - [ ] 項目119　パッケージでモジュールを整理して、安定したAPIを提供する
  - [ ] 項目120　実行環境に合わせてモジュールを調整する
  - [ ] 項目121　APIの基底例外を定義してAPIから呼び出し元を分離する
  - [ ] 項目122　循環インポートを解消する
  - [ ] 項目123　warningsでリファクタリングや移行を促進する
  - [ ] 項目124　静的型解析でバグを回避する
  - [ ] 項目125　Pythonプログラムのバンドルにはオープンソースツールを検討する
